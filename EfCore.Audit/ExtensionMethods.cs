using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Newtonsoft.Json;
#pragma warning disable 618

namespace EfCore.Audit
{
    public static class ExtensionsMethods
    {
        public static async Task<int> SaveChangesAsyncWithHistory<TDbContext>(
            this TDbContext context)
            where TDbContext : DbContext
        {
            var options = context.GetService<AuditOptions>();
            if (options == null)
                throw new Exception(
                    $"{nameof(AuditOptions)} was not registered. Make sure you call RegisterEntityFrameworkAuditing against your service provider");

            if (options.TestMode()) return await context.SaveChangesAsync();

            // Record all changes prior to saving
            var changes = context.OnBeforeSaveChanges(options);

            // Save changes
            var result = await context.SaveChangesAsync();

            // Save audit
            var auditItems = await context.OnAfterSaveChanges(changes, options);

            try
            {
                var postSaveAction = context.GetService<IPostSaveAction<TDbContext>>();
                if (postSaveAction != null)
                {
                    await postSaveAction.Handle(context, auditItems);
                }
            }
            catch (InvalidOperationException)
            {
                // GetService is the only option available via the DB Context, so we have to perform a try/catch :(
            }

            return result;
        }


        private static List<AuditEntry> OnBeforeSaveChanges(this DbContext context, AuditOptions options)
        {
            context.ChangeTracker.DetectChanges();
            var auditEntries = new List<AuditEntry>();
            foreach (var entry in context.ChangeTracker.Entries())
            {
                if (entry.State == EntityState.Detached || entry.State == EntityState.Unchanged)
                    continue;

                var auditEntry = new AuditEntry(entry)
                {
                    TableName = entry.Metadata.GetTableName(),
                    CreateBy = options.User(),
                    Client = options.Client(),
                    CreateDate = options.CurrentDateTime(),
                    Action = entry.State.ToString()
                };
                auditEntries.Add(auditEntry);

                foreach (var property in entry.Properties)
                {
                    if (property.IsTemporary)
                    {
                        // value will be generated by the database, get the value after saving
                        auditEntry.TemporaryProperties.Add(property);
                        continue;
                    }

                    var propertyName = property.Metadata.GetColumnName();
                    if (property.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[propertyName] = property.CurrentValue;
                        continue;
                    }

                    switch (entry.State)
                    {
                        case EntityState.Added:
                            auditEntry.Changes[propertyName] = new AuditEntry.Change
                                { NewValue = property.CurrentValue };
                            break;

                        case EntityState.Deleted:
                            auditEntry.Changes[propertyName] = new AuditEntry.Change
                                { OldValue = property.OriginalValue };
                            break;

                        case EntityState.Modified:
                            if (property.IsModified)
                                auditEntry.Changes[propertyName] = new AuditEntry.Change
                                {
                                    OldValue = property.OriginalValue,
                                    NewValue = property.CurrentValue
                                };

                            break;
                    }
                }
            }

            return auditEntries.ToList();
        }


        private static async Task<List<Audit>> OnAfterSaveChanges(this DbContext context,
            List<AuditEntry> auditEntries, AuditOptions options)
        {
            if (auditEntries == null || auditEntries.Count == 0) return new List<Audit>();

            var transactionId = options.TransactionId();
            var serializerSettings = options.JsonSerializerSettings;

            var result = new List<EntityEntry<Audit>>();

            foreach (var auditEntry in auditEntries)
                // Get the final value of the temporary properties
            foreach (var prop in auditEntry.TemporaryProperties)
                if (prop.Metadata.IsPrimaryKey())
                    auditEntry.KeyValues[prop.Metadata.GetColumnName()] = prop.CurrentValue;
                else
                    auditEntry.Changes[prop.Metadata.GetColumnName()] = new AuditEntry.Change
                        { NewValue = prop.CurrentValue };

            // Group together audit changes for the same table/key combination (e.g. owned entities which initially come through as distinct changes)
            var grouped = auditEntries.GroupBy(x => new
            {
                x.TableName, KeyValues = JsonConvert.SerializeObject(x.KeyValues, serializerSettings), x.Action,
                x.Client, x.CreateBy, x.CreateDate
            });
            foreach (var group in grouped)
                if (group.Count() > 1)
                    result.Add(context.Set<Audit>().Add(new Audit
                    {
                        TableName = group.Key.TableName,
                        Action = group.Key.Action,
                        Client = group.Key.Client,
                        CreateDate = group.Key.CreateDate,
                        CreatedBy = group.Key.CreateBy,
                        RowId = group.Key.KeyValues,
                        Data = JsonConvert.SerializeObject(
                            group.SelectMany(x => x.Changes).ToDictionary(pair => pair.Key, pair => pair.Value),
                            serializerSettings),
                        TransactionId = transactionId
                    }));
                else
                    // Save the Audit entry
                    result.Add(context.Set<Audit>()
                        .Add(group.First().ToAuditItem(transactionId, serializerSettings)));

            await context.SaveChangesAsync();

            return result.Select(x => x.Entity).ToList();
        }

        private static Audit ToAuditItem(this AuditEntry item, string transactionId,
            JsonSerializerSettings jsonSettings)
        {
            return new Audit
            {
                CreatedBy = item.CreateBy,
                CreateDate = item.CreateDate,
                Client = item.Client,
                Action = item.Action,
                TableName = item.TableName,
                RowId = JsonConvert.SerializeObject(item.KeyValues, jsonSettings),
                Data = JsonConvert.SerializeObject(item.Changes, jsonSettings),
                TransactionId = transactionId
            };
        }
    }

    public class AuditEntry
    {
        public AuditEntry(EntityEntry entry)
        {
            Entry = entry;
        }

        public EntityEntry Entry { get; }
        public string TableName { get; set; }

        public string Action { get; set; }
        public string CreateBy { get; set; }
        public string Client { get; set; }
        public DateTime CreateDate { get; set; }

        public Dictionary<string, object> KeyValues { get; } = new Dictionary<string, object>();
        public Dictionary<string, Change> Changes { get; } = new Dictionary<string, Change>();
        public List<PropertyEntry> TemporaryProperties { get; } = new List<PropertyEntry>();

        public class Change
        {
            public object OldValue { get; set; }
            public object NewValue { get; set; }
        }
    }
}